# Kiroツール初心者向け完全ガイド

## 目次
1. [Kiroとは何か](#1-kiroとは何か)
2. [セットアップガイド](#2-セットアップガイド)
3. [コア機能の詳細説明](#3-コア機能の詳細説明)
4. [実践的な使用例とベストプラクティス](#4-実践的な使用例とベストプラクティス)
5. [チームでの活用](#5-チームでの活用)

---

## 1. Kiroとは何か

### 1.1 Kiroの基本概要

Kiroは「**あなたが最高の仕事をするのを支援するAgentic IDE**」です。従来のIDEとは異なり、AI（人工知能）を核とした開発環境で、以下の特徴を持っています：

- **AI搭載の開発環境**: 自然言語でコードと対話できる
- **構造化された開発プロセス**: 要件定義から実装まで体系的にサポート
- **自動化されたワークフロー**: 反復的なタスクを自動化
- **プロジェクト固有のコンテキスト**: チーム独自のルールや慣習を学習
- **外部ツール連携**: 様々なサービスやAPIとの統合

### 1.2 主要機能の概要

| 機能 | 説明 | 用途 |
|------|------|------|
| **チャット** | AI搭載の自然言語インタラクション | コードの説明、生成、デバッグ |
| **スペック** | 構造化された開発計画管理 | 要件定義、設計、実装の追跡 |
| **フック** | 自動化されたワークフロー | ファイル操作時の自動実行 |
| **スチアリング** | プロジェクト固有のコンテキスト | チーム独自のルール適用 |
| **MCP** | 外部ツールとの連携 | 専門知識やAPIアクセス |

### 1.3 Kiroを使うメリット

1. **開発効率の向上**: AIがコード生成とデバッグを支援
2. **品質の向上**: 自動化されたチェックとレビュー
3. **チーム協働の改善**: 共通のルールと慣習の適用
4. **学習の加速**: 自然言語でのコード理解とドキュメント生成
5. **作業の自動化**: 反復的なタスクの削減

---

## 2. セットアップガイド

### 2.1 インストール方法

1. **公式サイトからダウンロード**
   - [kiro.dev](https://kiro.dev)にアクセス
   - お使いのOS（Windows、macOS、Linux）に対応したバージョンを選択
   - ダウンロードしたファイルを実行してインストール

2. **初回起動**
   - インストール完了後、Kiroを起動
   - 初期設定ウィザードに従って基本設定を完了
   - 所要時間: 約5分

### 2.2 基本的な使い方

#### 2.2.1 プロジェクトの開始

1. **新しいプロジェクトを作成**
   ```
   File > New Project
   ```

2. **既存のプロジェクトを開く**
   ```
   File > Open Project
   ```

#### 2.2.2 基本的なショートカット

| 操作 | Windows/Linux | macOS |
|------|---------------|-------|
| チャットを開く | `Ctrl+L` | `Cmd+L` |
| コマンドパレット | `Ctrl+Shift+P` | `Cmd+Shift+P` |
| サイドバー | `Ctrl+Alt+B` | `Cmd+Opt+B` |
| 設定 | `Ctrl+,` | `Cmd+,` |

### 2.3 初期設定

#### 2.3.1 基本設定

1. **設定画面を開く**
   ```
   Cmd+, (macOS) または Ctrl+, (Windows/Linux)
   ```

2. **重要な設定項目**
   - **AI Model**: 使用するAIモデルの選択
   - **Auto-save**: 自動保存の設定
   - **Theme**: ダーク/ライトモードの選択
   - **Privacy**: コードのプライバシー設定

#### 2.3.2 プライバシー設定

Kiroは以下のプライバシー機能を提供します：

- **ローカル処理**: 機密コードをローカルで処理
- **選択的共有**: 特定のファイルのみAIと共有
- **データ暗号化**: 通信とストレージの暗号化

---

## 3. コア機能の詳細説明

### 3.1 チャット機能

#### 3.1.1 基本的な使い方

チャット機能は、自然言語でコードと対話できる強力な機能です。

**アクセス方法：**
- キーボードショートカット: `Cmd+L` (macOS) / `Ctrl+L` (Windows/Linux)
- コマンドパレット: `Cmd+Shift+P` → "Kiro: Open Chat"
- サイドバー: `Cmd+Opt+B` → チャットパネルをクリック

#### 3.1.2 コンテキストプロバイダー

`#`記号を使って、特定のコンテキストを追加できます：

```
#codebase - プロジェクト全体を検索
#file - 特定のファイルを参照
#terminal - ターミナル出力を含める
#git diff - Git変更を確認
```

#### 3.1.3 実用的な使用例

1. **コードの説明**
   ```
   認証機能の動作を説明してください
   ```

2. **コード生成**
   ```
   Reactコンポーネントを作成してください
   ```

3. **デバッグ支援**
   ```
   この関数のエラーを修正してください
   ```

4. **リファクタリング**
   ```
   このコードをより効率的に書き直してください
   ```

### 3.2 スペック機能

#### 3.2.1 スペックとは

スペック（仕様）は、複雑な機能開発を構造化して管理するための機能です。

**3つのフェーズ：**
1. **要件定義** (Requirements)
2. **設計** (Design)
3. **実装** (Implementation)

#### 3.2.2 スペックの作成

1. **Kiroパネルから作成**
   ```
   Kiroパネル > Specs > + ボタン
   ```

2. **チャットパネルから作成**
   ```
   チャットパネル > Spec を選択
   ```

#### 3.2.3 活用方法

1. **プロジェクトアイデアの記述**
   ```
   新しいユーザー認証システムを作成したい
   ```

2. **要件の詳細化**
   - ユーザーストーリーの作成
   - 受け入れ基準の定義
   - 技術的制約の明確化

3. **設計の文書化**
   - アーキテクチャ図の作成
   - シーケンス図の生成
   - API仕様の定義

4. **実装の追跡**
   - タスクの進捗管理
   - コードレビューの実施
   - テストの実行

### 3.3 フック機能

#### 3.3.1 フックとは

フック（Hook）は、特定のIDEイベントが発生した時に自動実行される処理です。

**サポートされるイベント：**
- **ファイル作成時** (On File Create)
- **ファイル保存時** (On File Save)
- **ファイル削除時** (On File Delete)
- **手動実行** (Manual Trigger)

#### 3.3.2 フックの作成

1. **Kiroパネルから作成**
   ```
   Kiroパネル > Agent Hooks > + ボタン
   ```

2. **コマンドパレットから作成**
   ```
   Cmd+Shift+P > "Kiro: Open Kiro Hook UI"
   ```

#### 3.3.3 フックの種類と使用例

##### On File Create（ファイル作成時）
```yaml
トリガー: 新しいReactコンポーネントファイルが作成された時
処理:
1. import文を追加
2. 関数コンポーネントのテンプレートを生成
3. PropTypesの定義を追加
```

##### On File Save（ファイル保存時）
```yaml
トリガー: JavaScript/TypeScriptファイルが保存された時
処理:
1. 対応するテストファイルを特定
2. リンティングチェックを実行
3. 関連ドキュメントを更新
```

##### On File Delete（ファイル削除時）
```yaml
トリガー: コンポーネントファイルが削除された時
処理:
1. 関連するimport文を検索
2. 不要なimport文を削除
3. 依存関係を更新
```

##### Manual Trigger（手動実行）
```yaml
目的: コードレビューの実行
処理:
1. コード品質の問題を特定
2. 潜在的なバグを検出
3. パフォーマンスの改善提案
```

#### 3.3.4 フックの管理

1. **有効/無効の切り替え**
   ```
   フック名の横の目アイコンをクリック
   ```

2. **フックの編集**
   ```
   フックを選択 > 設定を変更 > 保存
   ```

3. **フックの削除**
   ```
   フックを選択 > Delete Hook > 確認
   ```

4. **手動実行**
   ```
   フック名の横の再生ボタン（▷）をクリック
   ```

### 3.4 スチアリング機能

#### 3.4.1 スチアリングとは

スチアリング（Steering）は、プロジェクト固有のコンテキストをAIに提供する機能です。`.kiro/steering/`ディレクトリにMarkdownファイルとして保存されます。

#### 3.4.2 デフォルトのスチアリングファイル

1. **product.md**
   ```markdown
   # プロダクト情報
   - 目的: ECサイトの構築
   - ターゲットユーザー: 30-50代の女性
   - ビジネス目標: 月間売上500万円
   ```

2. **tech.md**
   ```markdown
   # 技術スタック
   - フロントエンド: React + TypeScript
   - バックエンド: Node.js + Express
   - データベース: PostgreSQL
   - クラウド: AWS
   ```

3. **structure.md**
   ```markdown
   # ファイル構成
   - /src/components/ - Reactコンポーネント
   - /src/hooks/ - カスタムフック
   - /src/utils/ - ユーティリティ関数
   - /tests/ - テストファイル
   ```

#### 3.4.3 インクルージョンモード

##### Always Included（常に含める）
```yaml
---
inclusion: always
---
```
すべてのAIインタラクションで参照される基本的なルール。

##### Conditional Inclusion（条件付き含める）
```yaml
---
inclusion: fileMatch
fileMatchPattern: "components/**/*.tsx"
---
```
特定のファイルタイプやディレクトリでのみ適用される。

##### Manual Inclusion（手動で含める）
```yaml
---
inclusion: manual
---
```
チャットで`#steering-file-name`として手動で参照する。

#### 3.4.4 実用的なスチアリング例

1. **コーディング規約**
   ```markdown
   # coding-standards.md
   ---
   inclusion: always
   ---
   
   ## 命名規則
   - 変数: camelCase
   - 定数: UPPER_SNAKE_CASE
   - 関数: camelCase
   - クラス: PascalCase
   
   ## コメント
   - 関数には必ずJSDocコメントを付ける
   - 複雑なロジックには説明コメントを追加
   ```

2. **APIガイドライン**
   ```markdown
   # api-guidelines.md
   ---
   inclusion: fileMatch
   fileMatchPattern: "api/**/*.ts"
   ---
   
   ## REST API設計
   - GET /api/users - ユーザー一覧取得
   - POST /api/users - ユーザー作成
   - PUT /api/users/:id - ユーザー更新
   - DELETE /api/users/:id - ユーザー削除
   
   ## エラーハンドリング
   - 400: バリデーションエラー
   - 401: 認証エラー
   - 403: 権限エラー
   - 404: リソース未発見
   - 500: サーバーエラー
   ```

3. **セキュリティポリシー**
   ```markdown
   # security-policy.md
   ---
   inclusion: always
   ---
   
   ## 機密情報の取り扱い
   - APIキーはハードコードしない
   - 環境変数を使用する
   - パスワードは必ずハッシュ化
   - SQLインジェクション対策を実装
   ```

### 3.5 MCP（Model Context Protocol）機能

#### 3.5.1 MCPとは

MCP（Model Context Protocol）は、Kiroが外部サーバーと連携して専門的なツールや情報にアクセスできるプロトコルです。

#### 3.5.2 主要機能

1. **専門知識ベースへのアクセス**
   - 技術ドキュメントの検索
   - フレームワーク固有の情報取得

2. **外部サービスとの連携**
   - API呼び出しの自動化
   - データの取得と更新

3. **カスタムツールの作成**
   - プロジェクト固有のワークフロー
   - 専門的なタスクの自動化

#### 3.5.3 MCPの設定

1. **設定画面を開く**
   ```
   Cmd+, (macOS) または Ctrl+, (Windows/Linux)
   ```

2. **MCP設定を有効化**
   ```
   設定で "MCP" を検索 > MCP support を有効化
   ```

3. **Kiroを再起動**
   ```
   変更を適用するため再起動が必要
   ```

#### 3.5.4 MCPサーバーの使用

1. **MCPサーバータブを確認**
   ```
   Kiroパネル > MCP servers
   ```

2. **設定されたサーバーを表示**
   ```
   接続状況とステータスを確認
   ```

3. **ツールの使用**
   ```
   ツールをクリック > チャットにプレースホルダーを挿入
   ```

#### 3.5.5 実用例：AWSドキュメンテーション

```
使用例: AWS Documentation MCP server
機能: AWSサービスの検索と推奨事項取得
活用方法: AWSの設定や最適化に関する質問を直接Kiro内で解決
```

---

## 4. 実践的な使用例とベストプラクティス

### 4.1 日常的な開発ワークフロー

#### 4.1.1 朝の開発開始時

1. **プロジェクトの状況確認**
   ```
   #git diff を使って昨日からの変更を確認
   ```

2. **今日のタスクの整理**
   ```
   スペック機能で実装予定の機能を確認
   ```

3. **開発環境の準備**
   ```
   関連するスチアリングファイルを確認
   ```

#### 4.1.2 新機能の開発

1. **要件の明確化**
   ```
   スペック機能でユーザーストーリーを作成
   ```

2. **設計の検討**
   ```
   チャット機能でアーキテクチャを相談
   ```

3. **コードの実装**
   ```
   AIアシスタントを使ってコード生成
   ```

4. **テストの作成**
   ```
   フック機能でテストを自動生成
   ```

#### 4.1.3 コードレビュー

1. **自動レビュー**
   ```
   手動フックでコード品質をチェック
   ```

2. **セキュリティチェック**
   ```
   セキュリティフックで脆弱性を検査
   ```

3. **ドキュメント生成**
   ```
   変更内容の説明を自動生成
   ```

### 4.2 プロジェクト別のベストプラクティス

#### 4.2.1 Reactプロジェクト

**スチアリング設定例：**
```markdown
# react-conventions.md
---
inclusion: fileMatch
fileMatchPattern: "src/**/*.tsx"
---

## コンポーネント作成規則
- 関数コンポーネントを使用
- PropTypesまたはTypeScriptで型定義
- デフォルトプロップスを設定
- メモ化が必要な場合はReact.memoを使用
```

**フック設定例：**
```yaml
トリガー: Reactコンポーネントファイル作成
処理:
1. 基本的なコンポーネント構造を生成
2. PropTypesの定義を追加
3. 対応するスタイルファイルを作成
4. Storybookストーリーを生成
```

#### 4.2.2 API開発プロジェクト

**スチアリング設定例：**
```markdown
# api-standards.md
---
inclusion: fileMatch
fileMatchPattern: "api/**/*.ts"
---

## API設計原則
- RESTful設計を遵守
- 適切なHTTPステータスコードを使用
- エラーレスポンスは統一形式
- APIドキュメントを自動生成
```

**フック設定例：**
```yaml
トリガー: APIエンドポイントファイル保存
処理:
1. OpenAPI仕様を更新
2. 統合テストを実行
3. セキュリティチェックを実施
4. ドキュメントを再生成
```

#### 4.2.3 データベースプロジェクト

**スチアリング設定例：**
```markdown
# database-conventions.md
---
inclusion: fileMatch
fileMatchPattern: "migrations/**/*.sql"
---

## データベース設計原則
- 命名規則: snake_case
- 主キーは必ずid
- 作成日時・更新日時カラムを必須
- 外部キー制約を適切に設定
```

### 4.3 よくある問題と解決方法

#### 4.3.1 パフォーマンス問題

**問題**: フックの実行が遅い
**解決方法**:
```yaml
対策:
1. ファイルパターンを具体的に指定
2. 複雑な処理を分割
3. 並列実行を検討
4. キャッシュを活用
```

#### 4.3.2 エラー処理

**問題**: フックが予期しないエラーで停止
**解決方法**:
```yaml
対策:
1. エラーハンドリングを強化
2. 例外ケースをテスト
3. ログ出力を追加
4. フォールバック処理を実装
```

#### 4.3.3 チーム協働

**問題**: チームメンバー間での設定の不一致
**解決方法**:
```yaml
対策:
1. スチアリングファイルをバージョン管理
2. 標準的なフック設定を共有
3. ドキュメント化を徹底
4. 定期的な設定レビュー
```

---

## 5. チームでの活用

### 5.1 チーム設定の標準化

#### 5.1.1 スチアリングファイルの共有

1. **バージョン管理への追加**
   ```bash
   git add .kiro/steering/
   git commit -m "Add team steering configuration"
   ```

2. **標準設定の作成**
   ```
   .kiro/steering/team-standards.md
   .kiro/steering/code-review.md
   .kiro/steering/deployment.md
   ```

3. **プロジェクト固有の設定**
   ```
   .kiro/steering/project-specific.md
   ```

#### 5.1.2 共通フックの作成

1. **コード品質チェック**
   ```yaml
   名前: Team Code Quality Check
   トリガー: File Save
   対象: *.js, *.ts, *.tsx
   処理: ESLint + Prettier + 型チェック
   ```

2. **セキュリティ監査**
   ```yaml
   名前: Security Audit
   トリガー: File Save
   対象: すべてのファイル
   処理: 機密情報の検出、脆弱性チェック
   ```

3. **ドキュメント更新**
   ```yaml
   名前: Documentation Update
   トリガー: Manual
   対象: 変更されたファイル
   処理: README、API仕様の自動更新
   ```

### 5.2 開発プロセスの改善

#### 5.2.1 コードレビュープロセス

1. **プリコミットチェック**
   ```yaml
   フック: Pre-commit Security Scan
   目的: コミット前の自動セキュリティチェック
   効果: 問題の早期発見
   ```

2. **自動レビュー**
   ```yaml
   フック: Automated Code Review
   目的: コード品質の自動チェック
   効果: レビュー時間の短縮
   ```

3. **ドキュメント生成**
   ```yaml
   フック: Documentation Generator
   目的: 変更内容の自動文書化
   効果: ドキュメントの最新性保持
   ```

#### 5.2.2 継続的インテグレーション

1. **テストの自動化**
   ```yaml
   フック: Test Coverage Maintainer
   目的: テストカバレッジの維持
   効果: 品質の向上
   ```

2. **国際化対応**
   ```yaml
   フック: Internationalization Helper
   目的: 翻訳キーの同期
   効果: 多言語対応の簡素化
   ```

### 5.3 知識共有とドキュメント化

#### 5.3.1 技術知識の共有

1. **技術決定の記録**
   ```markdown
   # tech-decisions.md
   ---
   inclusion: always
   ---
   
   ## アーキテクチャ決定記録
   - 2024-01-15: React Router v6採用
   - 2024-01-20: Zustand導入
   - 2024-01-25: Playwright採用
   ```

2. **トラブルシューティング**
   ```markdown
   # troubleshooting.md
   ---
   inclusion: manual
   ---
   
   ## よくある問題と解決方法
   - ビルドエラー: package.jsonの依存関係を確認
   - テスト失敗: 環境変数の設定を確認
   - デプロイ失敗: AWS認証情報を確認
   ```

#### 5.3.2 新メンバーのオンボーディング

1. **開発環境設定**
   ```markdown
   # onboarding.md
   ---
   inclusion: always
   ---
   
   ## 新メンバー向けガイド
   1. 必要なツールのインストール
   2. 環境変数の設定
   3. データベースの初期化
   4. 初回デプロイの実行
   ```

2. **コーディング規約の説明**
   ```markdown
   # coding-guide.md
   ---
   inclusion: always
   ---
   
   ## チーム固有の規約
   - ファイル命名規則
   - コミットメッセージの形式
   - コードレビューの観点
   - テストの書き方
   ```

### 5.4 プロジェクト管理の改善

#### 5.4.1 進捗管理

1. **スペック機能の活用**
   ```
   プロジェクト全体をスペックで管理
   - 要件定義フェーズ
   - 設計フェーズ
   - 実装フェーズ
   ```

2. **タスクの自動化**
   ```yaml
   フック: Progress Tracking
   目的: 実装進捗の自動記録
   効果: プロジェクト管理の効率化
   ```

#### 5.4.2 品質管理

1. **メトリクス収集**
   ```yaml
   フック: Quality Metrics
   目的: コード品質指標の収集
   効果: 品質向上の可視化
   ```

2. **自動テスト**
   ```yaml
   フック: Automated Testing
   目的: テストの自動実行
   効果: 回帰テストの効率化
   ```

---

## まとめ

このガイドでは、Kiroの基本的な使い方から高度な活用方法まで、初心者が段階的に学べるよう体系的に説明しました。

### 重要なポイント

1. **段階的な学習**: 基本機能から始めて、徐々に高度な機能を活用
2. **実践的な活用**: 日常の開発ワークフローに組み込む
3. **チーム協働**: 設定の共有とルールの統一
4. **継続的な改善**: フィードバックを基にした設定の調整

### 次のステップ

1. **基本機能の習得**: チャットとスペック機能から始める
2. **自動化の導入**: 簡単なフックから試してみる
3. **チーム標準の確立**: スチアリングファイルを整備する
4. **外部連携の活用**: MCP機能で専門ツールと連携する

Kiroを活用することで、開発効率と品質の向上、チーム協働の改善が期待できます。このガイドを参考に、自分のプロジェクトに最適な設定を見つけてください。